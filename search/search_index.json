{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"implementations/","title":"Implementations","text":"<p>Libraries implementing the LiteVector protocol:</p> Language Library Description C ltvc Compact C library for resource constrained environments Go ltvgo Go library implementing an interface compatible with marshal/json JavaScript ltvjs Single file JavaScript/TypeScript library compatible Node and browser environments Python ltvpy Pure Python (3.7+) serializer and deserializer with Numpy support <p>If you have an open source implementation that you would like to add to this list, let us know in an issue.</p>"},{"location":"spec/","title":"Specification","text":"<p>LiteVectors is a binary format </p> <p>The data model is most similar to JSON, with primitive types like strings and numbers, along with a small handful of organizational structures:</p> <ul> <li>struct - name/value pairs (also known as a dictionary, object, map, or associative array in some environments)</li> <li>list - an ordered sequence of values (a generic array)</li> <li>vector - a length prefixed dense array of values (a strongly typed array)</li> </ul>"},{"location":"spec/#element-layout","title":"Element Layout","text":"<p>LiteVector elements follow a traditional tag, length, value convention - all elements consist of a one byte tag and either a fixed length value, or length field and vector of values:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tag \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tag \u2502 Value  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Tag \u2502 Length \u2502 Vector \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"spec/#tag-format","title":"Tag Format","text":"<p>A tag byte is divided into two fields: a <code>type code</code> and a <code>size code</code>. The <code>type code</code> is stored in the high order 4 bits while the <code>size code</code> is stored in the lower 4 bits:</p> <pre><code>     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  Type  \u2502  Size  \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nBits: 7 6 5 4 | 3 2 1 0\n</code></pre> <p>The tag value <code>0xFF</code> is reserved as a NOP element, and should be ignored by a decoder. The NOP tag is used in advanced scenarios where an implementation needs precise control over vector alignment.</p>"},{"location":"spec/#primitive-types","title":"Primitive Types","text":"<p>There are 16 primitive types. Each type has a 'type size' - the size of a value of that type. </p> <ul> <li>All numeric values are little endian</li> <li>Signed integers are encoded in two's complement</li> <li><code>bool</code> is stored as a one byte value, 0 false, non-zero true</li> <li><code>float32</code> is the IEEE 754 binary32 encoding</li> <li><code>float64</code> is the IEEE 754 binary64 encoding</li> <li><code>string</code> is UTF-8</li> </ul> Type Code Name Description Type Size Min Max 0 nil Null / No value 0 1 struct Beginning of a <code>string</code>/value associative map 0 2 list Beginning of a (heterogenous) sequence of elements 0 3 end End tag for a <code>struct</code> or <code>list</code> 0 4 string UTF-8 encoded bytes 1 5 bool True / False 1 0 (false) 255 (true) 6 u8 Unsigned 8-bit integer 1 0 255 7 u16 Unsigned 16-bit integer 2 0 65535 8 u32 Unsigned 32-bit integer 4 0 4294967295 9 u64 Unsigned 64-bit integer 8 0 18446744073709551615 10 i8 Signed 8-bit integer 1 -128 127 11 i16 Signed 16-bit integer 2 -32768 32767 12 i32 Signed 32-bit integer 4 -2147483648 2147483647 13 i64 Signed 64-bit integer 8 -9223372036854775808 9223372036854775807 14 f32 IEEE-754 32-bit floating point number 4 -3.40282e+38 3.40282e+38 15 f64 IEEE-754 64-bit floating point number 8 -1.79769e+308 1.79769e+308"},{"location":"spec/#size-codes","title":"Size Codes","text":"<p>There are 5 size codes, indicating the size of the length field following the tag byte. In the case of a single element, the 0 <code>size code</code> indicates that no length field follows the tag. Any tag with a <code>size code</code> that is not 0 is followed by an unsigned integer containing the length of the following vector. The length field is always in bytes (not number of elements).</p> Size Code Name Description 0 single Single element, inline 1 size_1 Vector with 1 byte (uint8) length field 2 size_2 Vector with 2 byte (uint16) length field 3 size_4 Vector with 4 byte (uint32) length field 4 size_8 Vector with 8 byte (uint64) length field 5-15 unused"},{"location":"spec/#field-ordering-within-structs","title":"Field Ordering within Structs","text":"<p>LiteVectors requires fields in a <code>struct</code> to be written in a consistent order. The rational for this is that fields present earlier in a <code>struct</code> may affect deserialization of fields present later. Individual applications may selectively enforce or relax this requirement as they desire, but middleware services and libraries processing and forwarding LiteVector messages must take care to maintain the transmitted field order.</p>"},{"location":"spec/#default-list-semantics","title":"Default List Semantics","text":"<p>Within a given context such as a stream, socket, file, etc, LiteVector processing semantics are to behave as if in a list. Standalone elements are allowed, and multiple elements may be concatenated one after another.</p> <p>By convention, a file containing raw LiteVector elements should have a <code>.ltv</code> extension.</p>"},{"location":"spec/#limits-and-validation","title":"Limits and Validation","text":"<p>The NOP tag <code>0xFF</code> should be discarded before any other processing. </p> <p>A <code>size code</code> &gt; 4 is invalid and must be rejected. A <code>string</code> must be valid UTF-8. The <code>string</code> datatype has a unit length of 1 byte, so a string with a <code>size code</code> of 0 must be an ASCII character &lt;= 0x7F.</p> <p>The zero length elements <code>nil</code>, <code>struct</code>, <code>list</code>, and <code>end</code> must have a <code>size code</code> of 0.</p> <p>All length fields are expressed in bytes. A vector length must be a multiple of its type length. Primitive type sizes greater than one are always a power of two, so this can be efficiently checked with a statement similar to:</p> <pre><code>if ( vectorLength &amp; (typeSize-1)) != 0) {\n/* This is an error */\n}\n</code></pre> <p>All bit patterns for IEEE-754 binary32 and binary64 floating point numbers are valid. General purpose serializers should not scrub or alter floating point values, but pass them intact to application code to handle special cases.</p> <p>All <code>struct</code> field names are strings.</p> <p>Individual applications and libraries may set their own limits (or make them configurable) for the following:</p> <ul> <li>Vector size limits</li> <li>Struct and list nesting depth</li> <li>Number of consecutive <code>nop</code> bytes permitted</li> </ul>"},{"location":"spec/details/","title":"Implementation Details","text":""},{"location":"spec/details/#nop-tags-and-alignment","title":"NOP tags and Alignment","text":"<p>Alignment refers to the position of an element with respect to the start of a sequence of LiteVector elements (the start of a message or beginning of a file for example).</p> <p>Individual elements are unaligned. It is good form for vectors to be aligned to the size of their type. For example, a vector of 32-bit float values would have the first byte of the first element start at a 4-byte offset from the start of the message. This can be accomplished by inserting <code>NOP</code> values in the stream before the vector's tag.</p> <p>Aligning vectors allows deserializer code to optimize vector processing by processing vectors in place. If they are not aligned, then the receiver may need to perform additional work in order to use the vector data. However, serialization, deserialization, and alignment needs can change between applications, so alignment is not strictly required. Standard conformant deserializers should be able to deal with both aligned and unaligned vectors.</p>"},{"location":"spec/details/#standalone-integer-sizing","title":"Standalone Integer Sizing","text":"<p>For arrays of integers, LiteVectors takes the relatively hands off approach of 'set a datatype and go to town' - all elements are the same size and type.</p> <p>For standalone integers, however, different environments use different strategies. Some like C allow you to define an 'int' that adapts to the native word size of the hardware. Some JavaScript engines track whether a 'number' is an integer or not, and can fit it into about 2^53. Python 3 implements arbitrarily large integers.</p> <p>In order to implement a normalized interoperable format and not be wasteful with space, LiteVectors recommends a Goldilocks 'best fit' integer encoding for standalone integers. The rules are simple:</p> <ul> <li>Non-negative integers are encoded as unsigned types</li> <li>Negative integers are encoded as signed types</li> <li>Integers are encoded in the smallest type that will hold them (among u8, u16, u32, u64, i8, i16, i32, i64).</li> </ul> <p>By following these rules, most integers are stored relatively efficiently. Additionally, integer format is deterministic even between platforms with normally incompatible integer representations.</p> <p>Encoders should goldilocks fit standalone integers, and decoders should be ready to deserialize them into whichever platform type is appropriate.</p>"},{"location":"spec/details/#json-representation","title":"JSON Representation","text":"<p>LiteVectors support JSON representation for interoperability and diagnostics - JSON is often easier to read than hex.</p> LiteVector JSON JSON Example Note nil null JSON null struct object { 'age': 2, 'cat': true } JSON objects list array [1, \"brown\", \"cat\"] JSON array string string \"Hello JSON bool bool true, false (i,u)(8,16,32) number -100, 0, 200 Integers are JSON numbers i64, u64 string \"-100\", \"0\", \"200\" JSON string to avoid number overflow f32, f64 number 1.2, -5.9, \"NaN, \"Infinity\" JSON value is a number or one of the special strings \"NaN\", \"Infinity\" or \"-Infinity\" vector array [1, 2, 3, 4] Vectors of primitives follow the same encoding above, but in a JSON array"},{"location":"spec/tests/","title":"Test Vectors","text":"<p>Test vectors are like unit tests for a protocol - and perhaps one of the more important tools for creating interoperable systems.</p> <p>The LiteVector test suite consists of both positive test vectors - examples of encoded data that follow the protocol, and negative test vectors - examples of data that violate the protocol (and should raise an error in a decoder). </p> <p>Like yin and yang define themselves in terms of each other, positive and negative test vectors provide the benefit of outlining what is and what is not valid under the specification, and help highlight inconsistencies and misinterpretations.</p> <p>The test vectors are text files with alternating lines of test description and hex encoded data. For example, here are two positive vectors:</p> <pre><code>struct: {'a': {'b': {'c': 5} } }\n1040611040621040636005303030\nu8[]: [1, 2, 3, 4]\n610401020304\n</code></pre> <p>An implementation wanting to test against these would keep the first line as a description (<code>struct: {'a': {'b': {'c': 5} } }</code>) for printing or feedback, and then parse the second line <code>1040611040621040636005303030</code> into binary to feed to a parser. The parser should successfully read and validate this data. The next line contains another test description followed by another test vector.</p> <p>The current set of positive test vectors: litevectors_positive.txt.</p> <p>The current set of negative test vectors are litevectors_negative.txt.</p> <p>If you encounter an error that you think could have been caught with a good test vector, submit an issue - and let's make everyone's parsers better.</p>"}]}